# configuration_management_mirea_public

# Винокур Станислав ИКБО-40-24
## Практическая работа №1
Вариант №5

GUI / CLI

Разработать эмулятор для языка оболочки ОС. Необходимо сделать работу 
эмулятора  как  можно  более  похожей  на  работу  в  командной  строке  UNIX-
подобной ОС. 
Этап 1. REPL 
Цель:  создать  минимальный  прототип.  Большинство  функций  в  нем  пока 
представляют собой заглушки, но диалог с пользователем уже поддерживается. 
Требования: 
1. Приложение должно быть реализовано в форме графического интерфейса 
(GUI). 
2. Заголовок окна должен формироваться на основе реальных данных ОС, в 
которой исполняется эмулятор. Пример: Эмулятор - [username@hostname]. 
3. Реализовать парсер, который корректно обрабатывает аргументы в 
кавычках. 
4. Реализовать команды-заглушки, которые выводят свое имя и аргументы: ls, 
cd. 
5. Реализовать команду exit. 
6. Продемонстрировать работу прототипа в интерактивном режиме. 
Необходимо показать примеры работы всей реализованной 
функциональности, включая обработку ошибок. 
7. Результат выполнения этапа сохранить в репозиторий стандартно 
оформленным коммитом. 

Этап 2. Конфигурация 
Цель: сделать эмулятор настраиваемым, то есть поддержать ввод параметров 
пользователя в приложение. Организовать для этого этапа отладочный вывод всех 
заданных параметров при запуске эмулятора. 
Требования: 
1. Параметры командной строки: 
– Путь к физическому расположению VFS. 
– Путь к стартовому скрипту. 
2. Стартовый скрипт для выполнения команд эмулятора: останавливается при 
первой ошибке. При выполнении скрипта на экране отображается как ввод, 
так и вывод, имитируя диалог с пользователем. 
3. Создать несколько скриптов реальной ОС, в которой выполняется эмулятор. 
Включить в каждый скрипт вызовы эмулятора для тестирования всех 
поддерживаемых параметров командной строки. 
4. Результат выполнения этапа сохранить в репозиторий стандартно 
оформленным коммитом. 

Этап 3. VFS 
Цель: подключить виртуальную файловую систему (VFS). 
Требования: 
1. Все операции должны производиться в памяти. Запрещается распаковывать 
или иным образом модифицировать данные VFS, за исключением 
возможных служебных команд. 
2. Источником VFS является XML-файл. Для двоичных данных используется 
base64 или аналогичный формат. 
3. Сообщить об ошибке загрузки VFS (файл не найден, неверный формат). 
4. Создать несколько скриптов реальной ОС, в которой выполняется эмулятор. 
Включить в каждый скрипт вызовы эмулятора для тестирования работы c 
различными вариантами VFS (минимальный, несколько файлов, не менее 3 
уровней файлов и папок). 
5. Создать стартовый скрипт для тестирования всех реализованных на этом и 
прошлых этапах команд. Добавить туда примеры всех режимов команд, 
включая работу с VFS и обработку ошибок. 
6. Результат выполнения этапа сохранить в репозиторий стандартно 
оформленным коммитом. 

Этап 4. Основные команды 
Цель:  поддержать  команды,  имитирующие  работу  в  UNIX-подобной 
командной строке. 
Требования: 
1. Необходимо реализовать логику для ls и cd. 
2. Реализовать новые команды: echo, find, uname. 
3. Создать стартовый скрипт для тестирования всех реализованных на этом 
этапе команд. Добавить туда примеры всех режимов команд, включая 
работу с VFS и обработку ошибок. 
4. Результат выполнения этапа сохранить в репозиторий стандартно 
оформленным коммитом. 


Этап 5. Дополнительные команды 
Цель: поддержать более сложные команды, изменяющие состояние VFS, при 
этом модификации должны осуществляться только в памяти. 
Требования: 
1. Реализовать команды: touch, cp. 
2. Создать стартовый скрипт для тестирования всех реализованных на этом 
этапе команд. Добавить туда примеры всех режимов команд, включая 
работу с VFS и обработку ошибок. 
3. Результат выполнения этапа сохранить в репозиторий стандартно 
оформленным коммитом. 

## Что реализовано и как тестировать

Этап 1:
uv run shell_emulator.py

Этап 2:
uv run shell_emulator.py --vfs ./vfs --script ./scripts/demo_ok.emu
uv run shell_emulator.py --vfs ./vfs

sh scripts/run_only_script.sh

Этап 3:
Запуск:
- XML (основной режим):
  uv run shell_emulator.py --vfs ./vfs/minimal.xml
  uv run shell_emulator.py --vfs ./vfs/three_levels.xml --script ./scripts/demo_ok.emu

- Проверка ошибок:
  uv run shell_emulator.py --vfs ./vfs/bad.xml
  (Эмулятор выведет "Ошибка загрузки VFS: ..." и продолжит с минимальной VFS по умолчанию.)

- Совместимость (каталог → импорт в память):
  uv run shell_emulator.py --vfs ./vfs

Этап 4.
Добавлено:
- uname: минимальная эмуляция
  * Без флагов: выводит "VFS-Emu"
  * -a: VFS-Emu <hostname> 0.1 x86_64 GNU/Linux
  * -s/-n/-r/-m/-p/-o: выводит выбранные поля (в порядке указания)
- find [path] [-name PATTERN] [-type f|d] [-maxdepth N]
  * path по умолчанию: .
  * PATTERN — маска (fnmatch, поддерживает * и ?)
  * -type: фильтр по типу (f – файл, d – каталог)
  * -maxdepth: ограничение глубины (0 — только стартовый узел)

Примеры:
  uv run shell_emulator.py --vfs ./vfs/minimal.xml --script ./scripts/demo_stage4.emu
  uv run shell_emulator.py --vfs ./vfs/three_levels.xml --script ./scripts/demo_stage4.emu

Этап 5. Добавлено:

- `touch FILE...`
  - Создаёт пустой файл, если его нет.
  - Если файл уже есть — ничего не делает.
  - Для каталогов `touch` не применим (будет сообщение об ошибке).

- `cp [-r] SRC DST`
  - Копирование файлов и каталогов **только в памяти** (VFS).
  - Без `-r` копируются **только файлы**. Для каталогов требуется флаг `-r`.
  - Если `DST` — существующий файл и `SRC` — файл, будет **перезапись**.
  - Если `DST` — существующий каталог, копия попадёт внутрь как `DST/SRC_NAME`.
  - Для каталогов **не выполняется слияние**: если цель-каталог уже существует — будет ошибка.

Примеры запуска:
uv run shell_emulator.py --vfs ./vfs/minimal.xml --script ./scripts/demo_stage5_minimal.emu

uv run shell_emulator.py --vfs ./vfs/three_levels.xml --script ./scripts/demo_stage5_three_levels.emu

## Практическая работа №2
Вариант №5

Разработать инструмент визуализации графа зависимостей для менеджера
пакетов. Готовые средства (менеджеры пакетов, библиотеки) для получения
зависимостей использовать нельзя.

Этап 1. Минимальный прототип с конфигурацией
Цель: создать минимальное CLI-приложение и сделать его настраиваемым.
Требования:
1. Источником настраиваемых пользователем параметров являются опции
командной строки.
2. К настраиваемым параметрам относятся:
– Имя анализируемого пакета.
– URL-адрес репозитория или путь к файлу тестового репозитория.
– Режим работы с тестовым репозиторием.
– Версия пакета.
– Режим вывода зависимостей в формате ASCII-дерева.
– Максимальная глубина анализа зависимостей.
– Подстрока для фильтрации пакетов.
3. (только для этого этапа) При запуске приложения вывести все параметры,
настраиваемые пользователем, в формате ключ-значение.
4. Реализовать и продемонстрировать обработку ошибок для всех параметров.
5. Результат выполнения этапа сохранить в репозиторий стандартно
оформленным коммитом.

Этап 2. Сбор данных
Цель: реализовать основную логику получения данных о зависимостях для их
дальнейшего анализа и визуализации. Запрещено пользоваться менеджерами
пакетов и сторонними библиотеками для получения информации о зависимостях
пакетов.
Требования:
1. Использовать формат пакетов Rust (Cargo).
2. Информацию необходимо получить для заданной пользователем версии
пакета.
3. Извлечь информацию о прямых зависимостях заданного пользователем
пакета, используя URL-адрес репозитория.
4. (только для этого этапа) Вывести на экран все прямые зависимости
заданного пользователем пакета.
5. Результат выполнения этапа сохранить в репозиторий стандартно
оформленным коммитом.

Этап 3. Основные операции
Цель: построить граф зависимостей (с учетом транзитивности) и выполнить
основные операции над ним.
Требования:
1. Получение графа зависимостей реализовать алгоритмом BFS без рекурсии.
2. Проводить анализ с учетом максимальной глубины, заданной
пользователем.
3. Не учитывать при анализе пакеты, имя которых содержит заданную
пользователем подстроку.
4. Корректно обработать случаи наличия циклических зависимостей.
5. Поддержать режим тестирования. Вместо URL реального репозитория, дать
возможность пользователю указать путь к файлу описания графа
репозитория, где пакеты называются большими латинскими буквами. 
Продемонстрировать функциональность этого этапа на различных случаях
работы с тестовым репозиторием.
6. Результат выполнения этапа сохранить в репозиторий стандартно
оформленным коммитом.

Этап 4. Дополнительные операции
Цель: выполнить дополнительные операции над графом зависимостей.
Требования:
1. (только для этого этапа) Поддержать режим вывода на экран порядка
загрузки зависимостей для заданного пакета. Сравнить результаты с
реальным менеджером пакетов. Если есть расхождения в результатах,
объяснить их наличие.
2. Продемонстрировать функциональность этого этапа на различных случаях
работы с тестовым репозиторием.
3. Результат выполнения этапа сохранить в репозиторий стандартно
оформленным коммитом.

Этап 5. Визуализация
1. Сформировать текстовое представление графа зависимостей на языке
диаграмм Mermaid.
2. Вывести на экран описание графа на языке диаграмм.
3. Если задан соответствующий параметр, вывести на экран зависимости в
виде ASCII-дерева.
4. Продемонстрировать примеры визуализации зависимостей для трех
различных пакетов.
5. Сравнить результаты с выводом штатных инструментов визуализации для
выбранного менеджера пакетов. Если есть расхождения в результатах,
объяснить их наличие.
6. Результат выполнения этапа сохранить в репозиторий стандартно
оформленным коммитом.

## Что реализовано и как тестировать
### Этап 1
- Реализован прототип CLI `second_practic/dependency_cli.py`, который принимает все параметры этапа (имя пакета, репозиторий, режим тестового репозитория, версию, режим ASCII-дерева, максимальную глубину, фильтр) с базовой валидацией.
- Приложение выводит пары ключ-значение со всеми аргументами для наглядной проверки.

#### Как запускать
- Реальный режим (пример URL):
  ```bash
  uv run python second_practic/dependency_cli.py \
    --package sample-pkg \
    --repository https://example.com/repo.git \
    --version 1.2.3 \
    --ascii-mode compact \
    --max-depth 3 \
    --filter core
  ```
- Тестовый режим (локальный файл манифеста):
  ```bash
  uv run python second_practic/dependency_cli.py \
    --package sample \
    --repository ./second_practic/test_data/sample_crate/Cargo.toml \
    --version 1.0 \
    --test-mode file
  ```
- Проверка ошибок: укажите `--test-mode real` с локальным путём или отрицательную глубину (`--max-depth -1`) — CLI сообщит о проблеме.

### Этап 2
- Добавлена загрузка `Cargo.toml` из локального файла или по URL с проверкой совпадения имени пакета и версии с введёнными параметрами.
- Реализован разбор секции `[dependencies]`; выводятся все прямые зависимости в формате `имя: требование`.
- Обработаны типовые ошибки: отсутствие `[package]`, несоответствие имени/версии, некорректный TOML, сетевые сбои.

#### Как запускать
- Тестовый режим (готовый манифест):
  ```bash
  uv run python second_practic/dependency_cli.py \
    --package sample \
    --repository ./second_practic/test_data/sample_crate/Cargo.toml \
    --version 1.0 \
    --test-mode file
  ```
  После списка параметров появятся строки вида:
  ```
  Direct dependencies:
  - serde: 1.0
  - tokio: 1.35
  - log: 0.4
  ```
- Реальный режим: передайте URL на `Cargo.toml` (например, raw-файл на GitHub); при несоответствии имени или версии приложение завершится с ошибкой.
- Проверка ошибок: измените `--version` или `--package`, повредите TOML или очистите `[dependencies]` — CLI выдаст диагностическое сообщение и код возврата 1.

### Этап 3
- Построение полного графа зависимостей алгоритмом BFS без рекурсии, с учётом глубины и фильтра по подстроке.
- При обходе учитываются циклы: уже посещённые пакеты не анализируются повторно.
- Для тестового режима добавлен формат графа (`second_practic/test_data/graph_repo.txt`), где узлы описываются в виде `PACKAGE:DEP1,DEP2`.

#### Как запускать
- Демонстрация транзитивных зависимостей (готовый граф):
  ```bash
  uv run python second_practic/dependency_cli.py \
    --package A \
    --repository ./second_practic/test_data/graph_repo.txt \
    --version 0.1 \
    --test-mode file \
    --max-depth 3
  ```
  Вывод содержит уровни графа и список детей для каждого пакета.
- Ограничение глубины: задайте `--max-depth 1`, чтобы увидеть только прямые зависимости.
- Фильтрация пакетов: добавьте `--filter D` — узлы, содержащие `D`, будут пропущены, а список фильтрованных пакетов появится в конце вывода.

### Этап 4
- Добавлена топологическая сортировка для вывода порядка загрузки зависимостей (leaf → root), активируется флагом `--show-load-order`.
- Для циклических графов выводится предупреждение с перечнем узлов, которые образуют цикл, и порядок доступных зависимостей сохраняется по BFS.
- Результат можно сравнить со штатным инструментом (`cargo tree`) для валидации порядка загрузки в реальном проекте.

#### Как запускать
- Реальный (манифест):
  ```bash
  uv run python second_practic/dependency_cli.py \
    --package sample \
    --repository ./second_practic/test_data/sample_crate/Cargo.toml \
    --version 1.0 \
    --test-mode file \
    --show-load-order
  ```
  После списка зависимостей появится секция с порядком загрузки leaf → root.
- Циклический граф: 
  ```bash
  uv run python second_practic/dependency_cli.py \
    --package A \
    --repository ./second_practic/test_data/graph_repo.txt \
    --version 0.1 \
    --test-mode file \
    --max-depth 3 \
    --show-load-order
  ```
  Команда покажет частичный порядок и список узлов в цикле (A, C, E) для дальнейшего анализа и сравнения с результатом `cargo tree`.

### Этап 5
- После построения графа автоматически выводится описание на языке Mermaid (`graph TD ...`), которое можно вставить в любой онлайн-рендерер диаграмм.
- Параметр `--ascii-mode` теперь реально работает: поддержаны режимы `compact` (узел печатается один раз) и `full` (показываются повторные вхождения, циклы помечаются явным образом).
- На тех же данных можно сверить результаты визуализации с `cargo tree` или аналогами; расхождения удобно объяснять, сравнивая ASCII-дерево и порядок загрузки.

#### Как запускать
- Манифест Cargo (`compact`):
  ```bash
  uv run python second_practic/dependency_cli.py \
    --package sample \
    --repository ./second_practic/test_data/sample_crate/Cargo.toml \
    --version 1.0 \
    --test-mode file \
    --ascii-mode compact
  ```
  На экране появятся Mermaid-диаграмма и компактное ASCII-дерево.

- Тестовый граф (`full`, демонстрация цикла):
  ```bash
  uv run python second_practic/dependency_cli.py \
    --package A \
    --repository ./second_practic/test_data/graph_repo.txt \
    --version 0.1 \
    --test-mode file \
    --max-depth 3 \
    --ascii-mode full
  ```
  ASCII-дерево покажет ветку `E -> A (cycle)`, а Mermaid-диаграмма позволит визуально отследить цикл.

- Альтернативный пакет (`compact`, без цикла):
  ```bash
  uv run python second_practic/dependency_cli.py \
    --package B \
    --repository ./second_practic/test_data/graph_repo.txt \
    --version 0.1 \
    --test-mode file \
    --max-depth 2 \
    --ascii-mode compact
  ```
  Можно сравнить получившееся дерево с выводом `cargo tree -p B` (если есть реальный проект) и убедиться, что визуализация соответствует ожиданиям.
