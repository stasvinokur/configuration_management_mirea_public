# configuration_management_mirea_public

# Винокур Станислав ИКБО-40-24
## Практическая работа №1
Вариант №5

GUI / CLI

Разработать эмулятор для языка оболочки ОС. Необходимо сделать работу 
эмулятора  как  можно  более  похожей  на  работу  в  командной  строке  UNIX-
подобной ОС. 
Этап 1. REPL 
Цель:  создать  минимальный  прототип.  Большинство  функций  в  нем  пока 
представляют собой заглушки, но диалог с пользователем уже поддерживается. 
Требования: 
1. Приложение должно быть реализовано в форме графического интерфейса 
(GUI). 
2. Заголовок окна должен формироваться на основе реальных данных ОС, в 
которой исполняется эмулятор. Пример: Эмулятор - [username@hostname]. 
3. Реализовать парсер, который корректно обрабатывает аргументы в 
кавычках. 
4. Реализовать команды-заглушки, которые выводят свое имя и аргументы: ls, 
cd. 
5. Реализовать команду exit. 
6. Продемонстрировать работу прототипа в интерактивном режиме. 
Необходимо показать примеры работы всей реализованной 
функциональности, включая обработку ошибок. 
7. Результат выполнения этапа сохранить в репозиторий стандартно 
оформленным коммитом. 

Этап 2. Конфигурация 
Цель: сделать эмулятор настраиваемым, то есть поддержать ввод параметров 
пользователя в приложение. Организовать для этого этапа отладочный вывод всех 
заданных параметров при запуске эмулятора. 
Требования: 
1. Параметры командной строки: 
– Путь к физическому расположению VFS. 
– Путь к стартовому скрипту. 
2. Стартовый скрипт для выполнения команд эмулятора: останавливается при 
первой ошибке. При выполнении скрипта на экране отображается как ввод, 
так и вывод, имитируя диалог с пользователем. 
3. Создать несколько скриптов реальной ОС, в которой выполняется эмулятор. 
Включить в каждый скрипт вызовы эмулятора для тестирования всех 
поддерживаемых параметров командной строки. 
4. Результат выполнения этапа сохранить в репозиторий стандартно 
оформленным коммитом. 

Этап 3. VFS 
Цель: подключить виртуальную файловую систему (VFS). 
Требования: 
1. Все операции должны производиться в памяти. Запрещается распаковывать 
или иным образом модифицировать данные VFS, за исключением 
возможных служебных команд. 
2. Источником VFS является XML-файл. Для двоичных данных используется 
base64 или аналогичный формат. 
3. Сообщить об ошибке загрузки VFS (файл не найден, неверный формат). 
4. Создать несколько скриптов реальной ОС, в которой выполняется эмулятор. 
Включить в каждый скрипт вызовы эмулятора для тестирования работы c 
различными вариантами VFS (минимальный, несколько файлов, не менее 3 
уровней файлов и папок). 
5. Создать стартовый скрипт для тестирования всех реализованных на этом и 
прошлых этапах команд. Добавить туда примеры всех режимов команд, 
включая работу с VFS и обработку ошибок. 
6. Результат выполнения этапа сохранить в репозиторий стандартно 
оформленным коммитом. 

Этап 4. Основные команды 
Цель:  поддержать  команды,  имитирующие  работу  в  UNIX-подобной 
командной строке. 
Требования: 
1. Необходимо реализовать логику для ls и cd. 
2. Реализовать новые команды: echo, find, uname. 
3. Создать стартовый скрипт для тестирования всех реализованных на этом 
этапе команд. Добавить туда примеры всех режимов команд, включая 
работу с VFS и обработку ошибок. 
4. Результат выполнения этапа сохранить в репозиторий стандартно 
оформленным коммитом. 


Этап 5. Дополнительные команды 
Цель: поддержать более сложные команды, изменяющие состояние VFS, при 
этом модификации должны осуществляться только в памяти. 
Требования: 
1. Реализовать команды: touch, cp. 
2. Создать стартовый скрипт для тестирования всех реализованных на этом 
этапе команд. Добавить туда примеры всех режимов команд, включая 
работу с VFS и обработку ошибок. 
3. Результат выполнения этапа сохранить в репозиторий стандартно 
оформленным коммитом. 

## Что реализовано и как тестировать

Этап 2:
uv run shell_emulator.py --vfs ./vfs --script ./scripts/demo_ok.emu
uv run shell_emulator.py --vfs ./vfs

sh scripts/run_only_script.sh

Этап 3:
Запуск:
- XML (основной режим):
  uv run shell_emulator.py --vfs ./vfs/minimal.xml
  uv run shell_emulator.py --vfs ./vfs/three_levels.xml --script ./scripts/demo_ok.emu

- Проверка ошибок:
  uv run shell_emulator.py --vfs ./vfs/bad.xml
  (Эмулятор выведет "Ошибка загрузки VFS: ..." и продолжит с минимальной VFS по умолчанию.)

- Совместимость (каталог → импорт в память):
  uv run shell_emulator.py --vfs ./vfs

Этап 4.
Добавлено:
- uname: минимальная эмуляция
  * Без флагов: выводит "VFS-Emu"
  * -a: VFS-Emu <hostname> 0.1 x86_64 GNU/Linux
  * -s/-n/-r/-m/-p/-o: выводит выбранные поля (в порядке указания)
- find [path] [-name PATTERN] [-type f|d] [-maxdepth N]
  * path по умолчанию: .
  * PATTERN — маска (fnmatch, поддерживает * и ?)
  * -type: фильтр по типу (f – файл, d – каталог)
  * -maxdepth: ограничение глубины (0 — только стартовый узел)

Примеры:
  uv run shell_emulator.py --vfs ./vfs/minimal.xml --script ./scripts/demo_stage4.emu
  uv run shell_emulator.py --vfs ./vfs/three_levels.xml --script ./scripts/demo_stage4.emu

Этап 5. Добавлено:

- `touch FILE...`
  - Создаёт пустой файл, если его нет.
  - Если файл уже есть — ничего не делает.
  - Для каталогов `touch` не применим (будет сообщение об ошибке).

- `cp [-r] SRC DST`
  - Копирование файлов и каталогов **только в памяти** (VFS).
  - Без `-r` копируются **только файлы**. Для каталогов требуется флаг `-r`.
  - Если `DST` — существующий файл и `SRC` — файл, будет **перезапись**.
  - Если `DST` — существующий каталог, копия попадёт внутрь как `DST/SRC_NAME`.
  - Для каталогов **не выполняется слияние**: если цель-каталог уже существует — будет ошибка.

Примеры запуска:
uv run shell_emulator.py --vfs ./vfs/minimal.xml --script ./scripts/demo_stage5_minimal.emu

uv run shell_emulator.py --vfs ./vfs/three_levels.xml --script ./scripts/demo_stage5_three_levels.emu